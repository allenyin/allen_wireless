function [signals, waveformData, refSpikeTimes, dataSpikeTimes] = wirelessMetric(data, reference)

    % Plot and compare the measured wireless data against
    % a reference signal.
    %
    % data - name of the saved wireless file, without file extension.
    % reference - currently should only be signal generated by
    %             "Noisy Spike Generator MATLAB Software v1.1" by Leslie Smith and Nhamoinesu Mtetwa
    %             The named mat file contains variables r1, signals, and target. Details  given in the
    %             manual for the software.

    Fs = 31250;         % Wireless sampling frequency
    load(reference);    % r1, signals, target

    refSpikeTimes = target.targettimes.';  % in seconds, convert to column

    % Load wireless data
    waveformFile = sprintf('%s.nlg', data);
    spikeFile = sprintf('%s.mat', data);

    % waveform data
    waveformData = plot_raw_channels(waveformFile, 'noplot');
    waveformData = waveformData(1,:)./128;  % only first channel is sorted, normalize to [-1,1]

    align_by_waveform(waveformData, signals, Fs);

    % Load spike data, this loads the following into workspace
    %   spike_ch   - Array with channel# for which a spike has been detected. 
    %   spike_ts   - Array of spike times. Indexes time or mstimer. Spikes are
    %                sorted on headstage but timestamped on the bridge by receiving time.
    %                Same length as spike_ch.
    %   spike_unit - Same length of spike_ch, tells which unit on the given channel has spike.
    %   strobe_rx  - Time when strobe is received.
    %   strobe_tx  - Time when stribe is transmitted.
    %   mstimer    - Hardware clock on bridge, runs at 9155.273438Hz. One entry per packet received.
    %                Used for timestamping spikes, i.e. when a packet with a spike is received on by
    %                the bridge, the packet rx-time is used for spike time. Probably lags the actual
    %                spike detection time by around 768us
    %   time       - Wall time within the client, synchronous to any BMI3 client talking to gtkclient.
    %                One time per packet received by gtkclient. Does not have sufficient resolution for
    %                spikes, may arrive out of order.
    %   track_frame
    load(spikeFile);
    f_mstimer = 9155.273438;        % Hz
    mstimer = double(mstimer);      % convert from uint32 to double
    spike_ts = double(spike_ts);    % convert from uint32 to double    
    
    dataSpikeTimes = mstimer(spike_ts);                                 % spike times in bridge time
    dataSpikeTimes = (dataSpikeTimes - dataSpikeTimes(1))./f_mstimer;   % Now in seconds

    % aligning by spike times doesn't work...gives results that's no way correct
    %align_by_spikeTimes(refSpikeTimes, dataSpikeTimes);
end

function align_by_spikeTimes(refSpikeTimes, dataSpikeTimes)
    % Based on spike timings, find the lag between the recording to reference

    [acor, lag] = xcorr(refSpikeTimes, dataSpikeTimes);
    [~, I] = max(abs(acor));
    lagDiff = lag(I);
end

function align_by_waveform(waveformData, signals, Fs)

    %% TODO...trying aligning after filtering waveformData with moving average filter
    %         to take out the noisy quiet data?

    % Plot original data together with reference
    figure;
    plot(signals); hold on;
    plot(waveformData, 'r');
    ylim([-1.3,1.3]);
    title('Reference and Recording');

    % analyze xcorrelation to match the beginning of reference to 
    % the recording -- not necessarily the same length due to system lag.
    [acor, lag] = xcorr(signals, waveformData);
    [~, I] = max(abs(acor));
    lagDiff = lag(I);
    figure;
    plot(signals); hold on;
    recordingEnd = min([(-lagDiff+numel(signals)-1),numel(waveformData)]);
    plot(waveformData(-lagDiff:recordingEnd), 'r');
    ylim([-1.3,1.3]);
    title('Reference and Recording aligned');

    fprintf('Align by waveform: recording lag reference by %0.5f seconds\n', -lagDiff/Fs);
    fprintf('                   recording lag reference by %d samples\n', -lagDiff);
end
